## 项目难点

### 1. 协程

协程，又称微线程，纤程。协程是一种用户态的轻量级线程，实现单线程的并发。有栈协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。

协程优点：

- 无需线程上下文切换的开销

- 无需原子操作锁定及同步的开销（协程本身就是单线程，单线程操作是原子的不需要加锁）

- 替代异步回调的代码风格，方便切换控制流，简化编程模型。

  （协程令开发者可以用同步的代码编写方式达到异步 IO 的效果和性能，避免了传统异步回调所带来的离散的代码逻辑和陷入多层回调中导致代码无法维护。但相比普通的异步回调程序，协程写法会多增加额外的内存占用和一些 CPU 开销。 ）

- 高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。

缺点：

- 无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上
- 进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序

### 2. 如何实现高并发？

并发模型主要是epoll + 非阻塞异步I/O + 协程调度器

- 使用epoll边沿触发的I/O多路复用技术，accept_worker协程调度器（单线程）高效地处理多个连接请求。
- 使用非对称协程调度方式实现协程调度器，将可调度的协程放入链表list中，顺序取出可调度协程，调度一次后如果状态为Ready,则重新插入链表尾部，等待调度器调度。
- 使用ucontext实现协程上下文切换；
- 使用非阻塞I/O，当数据没准备好时立即返回，并errno设置为EAGAIN。
- 当遇到IO数据没准备好时，则自动切换任务，向协程调度器注册I/O和超时事件并挂起协程，待I/O或超时事件触发则恢复协程继续进行异步I/O操作。（Hook模块）。
- 在多核处理器情况下，可以利用多线程抢夺更多的处理器资源，通过调度器来实现多协程在多线程上运行，这时也就具有并行的特性。







*推荐阅读*

http://www.iigrowing.cn/?p=6736

https://www.jianshu.com/p/837bb161793a

https://blog.csdn.net/hhyjiayou/article/details/80661666



